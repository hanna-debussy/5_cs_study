# CPU 스케줄링



**CPU 스케줄러(CPU Scheduler)**는 다중 프로그램 운영체제의 기본으로 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 한다. 이 스케줄러가 하는 CPU 스테줄링은 <u>어떤 프로세스에 CPU를 배정할지 결정</u>하고, 이 작업은 컴퓨터 시스템 효율에 직결되는 중요한 일이다.



#### 목적

* **공평성** : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.
* **효율성** : 시스템 자원을 놀리는 시간 없이 스케줄링 해야 한다.
* **안정성** : 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.
* **반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
* **무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.



#### 프로세스 생명주기



![https://t1.daumcdn.net/cfile/tistory/27033450580366160E](https://t1.daumcdn.net/cfile/tistory/27033450580366160E)



* **승인 (Admitted)** : 프로세스 생성이 가능하여 승인됨
* **스케줄러 디스패치 (Scheduler Dispatch)** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
* **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
* **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것
* **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것



#### CPU - I/O 버스트 사이클 (CPU - I/O Burst Cycle)

프로세스의 실행은 CPU 실행과 I/O 대기의 사이클로 구성된다.

프로세스의 실행은 CPU Burst로 시작된다. 뒤이어 I/O Burst가 발생하고, 그 뒤를 이어 또 다른 CPU Burst가 발생하며, 이어 또 다른 I/O Burst 등으로 진행된다. 결국 아래의 그림처럼 마지막 CPU Burst는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

![https://imbf.github.io/assets/computer-science/CPU-Scheduling-1.png](https://imbf.github.io/assets/computer-science/CPU-Scheduling-1.png)



#### CPU 스케줄러

CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. 선택 절차는 CPU 스케줄러에 의해 수행된다.

CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.



#### 선점 및 비선점 스케쥴링

CPU 스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.

> 1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
> 2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
> 3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
> 4. 프로세스가 종료할 때



**비선점 스케줄링(nonpreemptive)** 에서는 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다. (1, 4번) 오버헤드가 상대적으로 적지만 프로세스 배치에 따라 효율성 차이가 많이 난다.

**선점 스케줄링(preemptive)** 은 인터럽트나 시스템 호출시에 더 높은 우선 순위 프로세스가 발생되었음을 알았을 때, 현재 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다. (2, 3번) 따라서 우선 순위가 높은 프로세스를 빠르게 처리해야 할 경우 유용하지만, 선점이 일어날 경우 오버헤드가 발생하며 처리시간을 예측하기가 힘들다.



#### 스케줄링 기준 (Scheduling Criteria)

여러 CPU 스케줄링 알고리즘 사이에서 하나를 선택하기 위한 CPU 스케줄링 비교 기준

* CPU 이용률 (Utilization) : 어느 기간 동안 또는 특정 스냅샷에서의 CPU 이용률을 말한다. 

* 처리량 (Throughput) : 단위 시간당 완료된 프로세스의 개수. 즉, CPU 버스트를 처리한 수다.

  ---

* 총 처리 시간 (Turnaround Time) : 프로세스의 제출 시간과 완료 시간의 간격을 총 처리 시간이라고 한다.
* 대기 시간 (Waiting Time) : 대기 시간은 프로세스가 준비 큐에서 대기하면서 보낸 시간의 합이다.
* 응답 시간 (Response Time) : 하나의 Request를 제출한 후 첫 번째 Response가 나올 때까지의 시간이다.



**CPU Utilization, Throughput을 최대화하고, Turnaround Time, Waiting Time, Response Time을 최소화**하는 알고리즘의 선택이 바람직한 선택이다.



#### 스케줄링 알고리즘

* ##### 선입 선처리 알고리즘 (First Come First Served Scheduling, FCFS)

  * 비선점형 알고리즘
  * 가장 간단한 CPU 스케줄링 알고리즘
  *  CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
  * 일단 CPU가 한 프로세스에 할당되면, 그 프로세스가 종료하든지 또는 I/O 처리를 요구하든지 하여 CPU를 방출할 때까지 CPU를 점유한다.
  * 선입 선처리 정책하에서 평균 대기 시간은 종종 대단히 길 수 있다. 대화형 시스템에 적절하지 않다.

* ##### 최단 작업 우선 스케줄링 (Shortest Job First Scheduling, SJF)

  * 선점형 또는 비선점형 알고리즘
  * 비선점형일 경우 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택 발생
  * CPU 버스트 길이가 가장 작은 프로세스부터 순차적으로 CPU 코어를 할당한다.
  * 주어진 프로세스 집합에 대해 최소의 평균 대기시간을 가진다.
  * 그러나, 각 프로세스의 CPU 버스트 길이는 알 수 있는 방법이 없기 떄문에 프로세스 별 CPU 버스트의 길이를 예측해서 스케줄링 해야 한다.

* ##### 라운드 로빈 스케줄링 (Round Robin Scheduling, RR)

  * 선점형 알고리즘
  * FCFS와 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.
  * 시간 할당량(Time Quantum) 또는 타임 슬라이스(Time Slice)라고 하는 작은 단위의 시간을 정의한 후, CPU 스케줄러는 준비 큐를 돌면서 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.
  * RR 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다. 시간 할당량이 매우 크면 FCFS과 같아지고, 시간 할당량이 매우 적다면 매우 많은 문맥 교환이 이뤄지게 된다. 따라서 적절한 시간 할당량의 크기 설정이 중요하다. (보통 10 ~ 100ms)

* ##### 우선순위 스케줄링 (Priority Scheduling)

  * 선점형 또는 비선점형 알고리즘
  * 우선순위가 각 프로세스들에 연관되어 있으며, CPU 코어는 가장 높은 우선순위를 가진 프로세스에 할당된다.
  * 우선순위 스케줄링의 주요 문제는 **무한 봉쇄(Indefinite blocking)** 또는 **기아 상태(starvation)**이다.
    * 실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄된 것으로 간주할 수 있다. (Blocking)
    * 부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수도 있다. (Starvation)
  * 낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한가지 해결 방안은 **노화(Aging)**이다. 노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.
  * 우선순위 스케줄링과 라운드 로빈 스케줄링을 결합하는 방법을 통해 문제를 해결할 수도 있다.

* ##### 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

  * 우선순위 스케줄링이 라운드 로빈과 결합한 스케줄링 알고리즘

  * 우선순위가 각 프로세스에 정적으로 할당되며 프로세스는 실행시간 동안 동일한 큐에 남아있다.

  * 우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 프로세스가 처리되어야 다음 우선순위 큐가 실행될 수 있다.

    ![https://imbf.github.io/assets/computer-science/CPU-Scheduling-3.png](https://imbf.github.io/assets/computer-science/CPU-Scheduling-3.png)

  

  * 각 큐에는 자체 스케줄링 알고리즘을 구현할 수 있다.

* ##### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

  * 다단계 큐 스케줄링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다.
  * 이와 반대로 다단계 피드백 큐 스케줄링 알고리즘은 **프로세스가 큐들 사이를 이동하는 것을 허용**한다. 즉, 우선순위 변동이 가능하다.
  * 한 번 CPU를 할당받은 프로세스는 우선순위가 낮아지고, 우선순위가 높은 큐보다 우선순위가 낮은 큐에 시간 할당량을 크게 주어 어렵게 얻은 CPU를 좀 더 오랫동안 사용하게 해주는 방식
  * **Aging과 Starvation을 예방**한다.
  * 특정 시스템에 부합하도록 구성이 가능함으로 현대 사용되는 CPU 스케줄링 알고리즘 중 가장 일반적인 CPU 스케줄링 알고리즘이다.
  * 그러나 가장 좋은 스케줄러로 동작하기 위해서는 모든 매개변수 값들을 선정하는 특정 방법이 필요하기 떄문에 가장 복잡한 알고리즘이기도 하다.





---

#### 질문

1. 어떤 기준으로 CPU 스케줄링을 선택해야 하는가?
2. 스케줄링 알고리즘을 선점 스케줄링 방식과 비선점 스케줄링 방식으로 구분하여 설명하시오.







[참고자료]

* https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/CPU%20Scheduling.md
* https://preamtree.tistory.com/19
* https://bnzn2426.tistory.com/65
* https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html