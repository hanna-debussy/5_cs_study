# SSL/TLS 





SSL/TLS 인증서 : **클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서**. 



목적  :one: 클라이언트 입장에서는 접속한 서버가 신뢰할 수 있는 서버인지 판단 :two: 서버 입장에서는 SSL 통신에 사용될 공개키를 클라이언트에게 전달. 



종합 :one:을 하기 위해  공개키 서명 방식을 사용하는 것을 **SSL/TLS Handshake** 





## SSL/TLS 

- TLS/SSL 암호화 과정에서 필요한 정보(사용할 암호화 알고리즘, 키) 의 교환을 위한 것이 TLS Handshake 과정(즉 사람 간의 사전 약속이라고 생각해도 됨)

- SSL(Secure Sockets Layer)은 Certificate Authority(CA)라 불리는 서드 파티로부터 서버와 클라이언트 인증을 하는데 사용. 1994년 netscape 사의 웹 브라우저를 위한 보안 프로토콜로 처음 등장(3.0까지 발표)
- 1999년에 IETF(국제 인터넷 표준 기구)에서 SSL 3.0을 기반으로 TLS 1.0 버전 발표(현재는 1.2까지 나옴)

- TLS(Transport Layer Security)의 정의는 TCP 기반의 어플리케이션에 대한 종단간 보안서비스를 제공하기 위해 만들어진 전송계층 보안 프로토콜
- well-knowport - https(443), smtps(465), ftps(990), telnets(992)
- 제공하는 서비스는 기밀성(공유키를 통한 송수신 메시지 암호화 제공)/무결성(메시지 인증코드를 통해 송수신 메시지 위변조를 확인 서비스 제공)/인증(공개키 인증서를 이용한 서버/클라이언트 간의 상호 인증 수행)

- 모든 SSL/TLS 연결은 **"Handshake"** 과정이 반드시 필요(사전 약속도 안하고 약속에 나가는 것과 유사). 
- TLS는 2계층 구조/ 상위 계층은 handshake, change cipher spec, alert, application data/ 하위 계층은 record 프로토콜
- handshake - 종단 간에 보안 파리미터를 협상하기 위한 프로토콜/ change cipher spec -이미 형성된 보안 파라미터를 이후부터  적용/변경함을 알리는 프로토콜/ alert - 통신 과정 상 생겨나는 오류를 통보하기 위한 프로토콜 /  application data - 응용 계층의 데이터를 전달하기 위한 프로토콜
- record - 적용/변경된 보안 파라미터를 이용하여 실제 암호화/복호화 등등을 제공하는 프로토콜
- handshake 과의 결과 -  :one:통신을 암호화하는 데 사용할 암호화 알고리즘과 키를 결정(이때 TLS 버전도 정하게 됨) :two:신뢰할 수 있는 서버인지를 CA에서 발행한 인증서로 확인 :three:실제 데이터 전송을 시작하기 전에 보안 연결이 이루어 졌는지 확인

**- 대칭키 암호화**



![img](https://t1.daumcdn.net/cfile/tistory/99613A415C46AADE2A)





- 대칭키 암호는 암호화에 사용되는 키와 복호화에 사용되는 키가 동일한 기법

- 키 전달 및 관리에 어려움이 있지만(키 교환 방식이 필요함) 공개키에 비해 연산 속도가 빠름



**-공개키 암호화(비대칭키 암호화)**



대칭키가 가지는 키 교환 문제를 해결하고자 나온 방식이 공개키(특히 RSA)임. 암호화 키와 복호화 키가 다른 것이 특징



![img](https://t1.daumcdn.net/cfile/tistory/99575E435C46AE152A)



공개키 암호화는 비밀키 하나만 가지는 대칭 암호화 방식과 다르게 공개키와 비밀키 두 개가 존재합니다. 

누구에게나 공개 가능한 공개키, 자신만이 갖고 있는 개인키

- 송신자가 평문을 **수신자의 공개키**로 암호화하는 방식(암호모드-일반적인 데이터 암호화)

이 경우 수신자는 자신의 개인키로 데이터 복호화함. 오직 수신자만이 암호문을 평문으로 변환할 수 있음

- 송신자가 평문을  **자신의 개인키**로 암호화 하는 경우(서명모드-전자서명)

 송신자가 자신의 개인키로 인증서를 암호화하고 자신의 공개키와 함께 수신자에게 전달합니다. 수신자는 송신자의 공개키를 통해 인증서를 복호화를 함. 송신자의 오직 공개키로 복호화할 수 있다는 점에서 인증서가 공개키의 주인(송신자)에서 왔다는 것을 보장할 수 있음



## TLS/SSL handshake 방식에서 사용하는 암호화



- 'handshake' 그 자체는 공개키를 사용. 단 오버헤드가 크기 때문에 handshake 과정 이후에 실질적으로 데이터를 전달할 때에는 공유키로 암호화
- 서버/클라이언트 양측 모두 pre master secret(공개키와 개인키) 존재 => handshake를 거치면서 최종적으로 session key가 만들어짐
- 공유키는 대칭 암호화 알고리즘
- 종합 : handshake 과정은 **공개키**/ 이후에는 **비밀키** 사용. 



**HTTPS** 는 HTTP가 보안에 취약한 것을 보완하는 것으로써 ‘TLS 인증서’ 사용.

인증서는 클라이언트와 서버간의 HTTPS 통신에 사용되는 전자 문서

클라이언트는 서버에 접속한 직후 서버로부터 이 인증서를 내려받아 검증. 

서버를 신뢰할 수 있다면 계속 통신.

인증서에는 서버의 공개키가 있고 이 인증서는 CA의 개인키로 암호화됩니다.(이후 CA의 공개키로 복호화하여 인증서가 CA에서 왔다는 것을 알 수 있음 => 서명모드)

브라우저는 모든 CA들의 공개키를 가지고 있으므로 서버가 가진 CA의 인증서를 복호화하고 내용을 볼 수 있음. 



## TLS/SSL handshake 과정





![img](https://t1.daumcdn.net/cfile/tistory/9973E13B5C46B5B707)







1. TLS 클라이언트가 자신의 버전, 암호 알고리즘 목록, 그리고 사용 가능한 압축 방식을 "client hello" 메시지에 담아 서버로 보냄.
   - 클라이언트 랜덤 - 클라이언트가 생성하는 32바이트 난수값이며 master secret 및 키 블럭의 salt값
   - 세션 ID -  서버 세션을 식별하기 위한 id, 완전협상일 때에는 빈값 전달하지만, 단축협상일 때는 세션 id를 넘어서 전달함
   - 암호 도구 목록(cipher suite) - '키 교환 및 인증 알고리즘' + 암호 명세' / TLS_RSA_WITH_AES_256_CBC_SHA256



2. TLS 서버는 클라이언트가 제공한 목록에서 서버가 선택한 암호 알고리즘, 선택한 압축 방식과 세션 ID 및 CA(Certificate Authority)가 사인한 서버의 공개 인증서를 **"server hello"** 메시지에 담아 응답. 이 인증서는 대칭키가 생성되기 전까지 클라이언트가 나머지 handshake 과정을 암호화하는 데에 쓸 공개키를 담고 있음
   - 서버 랜덤 - 서버가 생성하는 32바이트 난수값이며, master secret 및 키 블럭의 salt값
   - 세션 ID
   - 암호 도구 목록 - 서버가 선택한 압축 방식 및 암호 알고리즘, 서버의 공개 인증서
   - 이때 키 교환 알고리즘을 RSA를 안하고 디피-헬만 방식으로 할 시에는 매개변수들을 서명값과 함께 같이 전송함(Sever Key Exchange)
   - 서버의 인증서 뿐만 아니라 인증기관들의 인증서 목록까지 클라이언트 쪽에서 요구할 경우 Certificate message를 보낼 수도 있음
   - 모든 정보가 서버에서 클라이언트에 보내졌을 때 Server hello done 메시지를 보냄



3. 클라이언트는 서버의 디지털 인증서가 유효한지 신뢰할 수 있는 CA 목록을 통해 확인 



4. 키 교환에 필요한 사전 마스터 비밀키를 생성하여  client key exchange 메시지에 담아 서버로 전달. 

   - RSA - 의사 난수 생성기로 난수 값울 생성 후 수신한 서버 인증서의 공개키로 암호화하여 전송(암호 모드)

   - 디피-헬만- 클라이언트가 디피-헬만 공개키를 생성하여 서버에게 전달. 클라이언트와 서버는 연산을 통해 공통의 사전 마스터 비밀키를 생성

   - 필요시에는 클라이언트의 인증서 목록을 전달하는 메시지인 client certificate 메시지를 보내기도 함(5와 같은 이야기)

   - 또한 클라이언트가 보낸 인증서에 대한 개인키를 클라이언트가 가지고 있음을 증명하는 메시지인 certifacte verify를 전달하기도 함

   - 모든 정보를 서버에게 보내는 데에 성공하면 Finished 메시지를 보냄(지금까지의 교환 내역을 해시한 값을 대칭키로 암호화하여 담음- 협상완료)

     

5.  SSL / TLS 서버가 "클라이언트 인증서 요청"을 보낸 경우 클라이언트는 클라이언트의 디지털 인증서 또는 "디지털 인증서 없음 경고" 와 함께 클라이언트의 개인 키로 암호화 된 임의의 바이트 문자열을 보냅니다. 이 경고는 경고일 뿐이지만 일부 구현에서 클라이언트 인증이 필수일 경우 handshake 실패



6. 서버는 클라이언트의 인증서를 확인합. RSA의 경우 수신자가 보낸 난수 바이트를 서버의  개인키로 복호화해 대칭 마스터키 생성. 디피-헬만은 공동의 사전 마스터 비밀키를 응용해서 사용

   

7. 서버는 스스로도 해시를 생성해 클라이언트에서 도착한 값과 일치하는지 확인. 일치하면 서버도 마찬가지로 대칭키를 통해 암호화한 Finished 메시지를 클라이언트에게 보냅니다.(협상 완료)

   

8. 이후부터 SSL / TLS 세션 동안 서버와 클라이언트는 대칭키로 암호화된 어플리케이션(HTTP) 데이터를 주고 받을 수 있습니다.



종합 - 사전 마스터 비밀키와 클라이언트 랜덤, 서버 랜덤을 조합한 해시한 결과가 마스터 비밀키/ 마스터 비밀키는 세션상태에 저장되어 이것이 데이터를 암복호화에 사용되는 키블럭임.(session-state에 저장되며 이후 완전협상 후 단축협상 및 데이터 송수신시 키 블럭으로 사용)



단축협상은 세션 유지라고 생각하며 되고, 세션 id를 서로 공유한다는 개념에 불과하므로 따로 다루지 않겠음



레코드 프로토콜은 응용계층의 데이터를  :one: 일정 크기로 단편화하고 :two: 이를 협상을 통해 적용된 압축 알고리즘으로 압축한 후 mac값을 추가 :three: 협상을 통해 적용된 암호 알고리즘을 적용하고 :four: 마지막으로 record 헤더를 추가



## 출처

- https://wangin9.tistory.com/entry/브라우저에-URL-입력-후-일어나는-일들-5TLSSSL-Handshake [잉구블로그]

- 2021 정보보안기사 실기(탑스핏)