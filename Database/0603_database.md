# 0603 데이터베이스 



## 데이터 모델링 개요

- 모델링 : 복잡한 현실세계를 추상화, 단순화하여 일정한 표기법에 의해 명확하게 표현하는 것
- **추상화(=모형화,덜 중요한 부분을 가리고 중요한 부분을 강조), 단순화, 명확화**
- 모델 - 현실 세계의 추상화된 반영
- 모델링의 관점
  - 데이터 관점(what) - 데이터와 데이터 간의 관계와 업무와 데이터 간 관계
  - 프로세스 관점(how) : 업무를 실제로 하고 있는 일 또는 햐야하는 일(어떤 순서로 처리되는지, 접근 방법)
  - 상관 관점 - 업무 처리방법에 따라 데이터가 받는 영향 모델링



### 데이터 모델링의 3단계



#### 개념적 모델링

- 학계 : ERD를 도출하고, 주로 chen 타입의 ERD 사용, 관계가 자체 속성을 가질 수 있음/ 산업계 : 핵심 엔터티/관계/속성 중심 ERD 도출, 관계가 자체 속성 가질 수 없음
- 결론 : ERD를 도출한다.



####  논리적 모델링

- 학계 : 테이블 도출, 기본키와 외래키 지정, 정규화 및 반정규화 수행/ 산업계 : 구체적인 ERD 도출, 식별자와 관계 명시, m:n 관계 해소
- 현실 세계를 추상화한 개념적 모델링을 좀 더 개념적으로



#### 물리적 모델링

- 학계 : 실제 dbms에 맞는 테이블 구축, 뷰 설계, 인덱스 설계/ 산업계 : 테이블 도출, 정규화 및 반정규화를 하면서 뷰 설계, 인덱스 설계

- 물리적 데이터베이스를 설계하며, 데이터 타입 정의 및 뷰, 인덱스를 설계한다.

  

### 데이터 독립성

- 파일 시스템은 응용 프로그램이 저마다 데이터를 관리,  중복된 데이터가 변경되었을 때 어떤 데이터가 맞는지 신뢰할 수 없음

- 따라서 프로그램과 데이터 간의 독립을 보장하는 데이터베이스를 사용

- 데이터 구조가 변경되어도 응용 프로그램이 변경될 필요가 없음

- 논리적 독립성(개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않음)와 물리적 독립성(내부스키마가 변경되어도 외부/개념 스키마 영향을 받지 않게 하는 것)으로 보장

  

### **스키마(Schema)**

데이터 베이스의 구조를 전반적으로 기술한 것. 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 등을 정의 한 것

 결론 - DBMS는 외부 스키마에 명세된 사용자의 요구사항을 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 반환한다

![img](https://blog.kakaocdn.net/dn/c0TOOU/btqARjcCd7S/PVdY4N5Ekn8D0KzKmgEdn1/img.png)



#### 외부 스키마

- 각 사용자 또는 프로그램의 관점 슼마



#### 개념 스키마

- 사용자가 필요한 데이터가 무엇이고, 어떻게 효율적으로 잘 정리하는 가의 문제
- 모든 사용자들의 관점을 통합한 스키마, db에 저장되는 데이터와 그의 관계
- 데이터 모델링(개념 스키마를 만들어가는 방식)은 여기에 속함



#### 내부 스키마

- 개념 스키마를 실제로 물리적 저장장치에 어떻게 저장할지의 문제
- 실제로 저장된 형식, 저장장치의 구조

 

## **데이터베이스**

- 파일 시스템의 응용 프로그램이 저마다 데이터를 관리하여  중복된 데이터가 변경되었을 때 어떤 데이터가 맞는지 신뢰할 수 없다는 단점을 극복하기 위해 등장
- 프로그램과 데이터 간의 독립성을 보장함. 컴퓨터 언어로 제어 가능하고 누구나 접근하고 편집 가능

 

### **데이터베이스의 특징**

1. 실시간 접근성(Real-Time Accessibility): 실시간 처리에 의한 응답이 가능해야 한다. 

2. 계속적인 변화(Continuous Evolution): 새로운 데이터의 삽입(Insert), 삭제(Delete), 갱신(Update)로 항상 최신의 데이터를 유지

3. 동시 공용(Concurrent Sharing): 다수의 사용자가 동시에 같은 내용의 데이터를 이용가능 

4. 내용에 의한 참조(Content Reference): 데이터베이스에 있는 데이터를 참조할 때 사용자의 요구에 따른 데이터 내용으로 데이터를 찾는다. 

 

### **데이터베이스(Database, DB) 용어**

- 관계형 데이터베이스: 여러개의 테이블이 관계로 이루어져있는 구조를 가진 데이터베이스.
- 엔티티(Entity): 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체. 
- 엔티티 집합(Entity Set): 동일한 속성을 가진 엔티티들의 집합. 엔티티 집합에 속한 요소들이 여러 엔티티 집합에 속할 수도 있다. 



### **표(Table) 관련 용어**

![img](https://blog.kakaocdn.net/dn/b5kBz8/btqARX70e1y/KXRB6TBXzanD2TYUnxpUk0/img.jpg)



- Relation(= Table): 관계형 데이터 베이스에서 정보를 구분하여 저장하는 기본 단위.
- Tuple(=Record): 테이블에서 행을 의미. 튜플은 릴레이션에서 같은 값을 가질 수 없다. 튜플의 수는 카디날리티(Cardinality)라고 한다. 
- Attribute( =Field): 테이블에서 열을 의미. 같은 말로는 칼럼이라고도 하며 어트리뷰트의 수는 디그리(Degree)라고도 한다. 
- 식별자(Identifier): 여러개의 집합체를 담고있는 관계형 데이터 베이스에서 각각의 구분할 수 있는 논리적인 개념
  - 특성
    - 유일성: 하나의 릴레이션에서 모든 행은 서로 다른 키 값을 가져야 한다. 
    - 최소성: 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다. 

#### **Key**

데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 **튜플들을 서로 구문할 수 있는 기준이 되는 속성**.

- 후보키(Cardidate Key)
  - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합.
  - 기본 키로 사용할 수 있는 속성들을 의미.
  - 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다.
  - 유일성과 최소성을 만족시켜야 한다. 
- 기본키(Primary Key)
  - 후보키 중에서 선택한 Main Key이다.
  - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성.
  - null 값을 가질 수 없다. 
  - 동일한 값이 중복되어 저장될 수 없다.
- 슈퍼키(Super Key)
  - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타나지 않는다.
  - 릴레이션을 구성하는 모든 튜플에 대해 유일성을 만족시키지만, 최소성을 만족시키지 못한다.
  - (ex) 학번 + 주민번호를 사용하여 슈퍼키를 만들면 유일성은 만족하지만, 학번이나 주민번호 하나만 가지고도 다른 튜플들을 구분할 수 있으므로 최소성은 만족시키지 못한다. 
- 외래키(Foregin Key)
  - 어떤 릴레이션간의 기본키를 참조하는 속성. 테이블들 간의 관계를 나타내기 위해서 사용된다.
  - 다른 릴레이션의 기본 키를 그대로 참조하는 속성의 집합을 의미. 
  - 외래키가 되는 속성과 기본키가 되는 속성의 이름은 달라도 되지만, 외래키의 속성의 도메인과 참조되는 기본키 속성의 도메인은 반드시 같아야 한다. 도메인이 같아여 연관성 있는 투플을 찾기 위한 비교 연산이 가능하기 때문이다.
  - 외래키는 기본키를 참조하지만 기본키가 아니기 때문에 null값을 가질 수 있고, 서로 다른 튜플이 같은 값을 가질 수 있다.



#### **관계 데이터 모델의 제약조건**

- 기본키를 구성하는 모든 속성은 null 값을 가질 수 없다. 
- 외래키는 참조할 수 없는 값을 가질 수 없다.

#### **데이터베이스 언어 종류**

- DML, Data Multipulation Language (데이터 조작어): 저장된 데이터를 실질적으로 처리하는데 사용하는 언어. 데이터 베이스의 생성 및 변경, 제거
- DDL, Data Definition Langauge(데이터 정의어): 데이터 베이스를 정의하는 언어. 데이터베이스 안의 값들을 변경, 수정, 입력.
- DCL, Data Control Language(데이터 제의어): 데이터베이스에 접근하거나 객체에 권한을 주는 역할. 데이터 베이스의 접속 권한 등을 수정.



## SQL Injection

- 웹 사이트의 보안 약점을 이용해 특정 SQL 쿼리문을 전송하여 공격자를 원하는 데이터의 중요한 정보를 가져오거나 변경하는 공격

- 클라이언트의 입력한 데이터를 필터링을 제대로 하지 않아 생긴다는 점에서 XSS와 유사하지만, XSS와는 다르게 데이터베이스를 직접 접근한다는 점과 입력 데이터를 무엇으로 인식하는가의 차이가 있음



### 종류

1. Error based SQL injection
   - 논리적 에러를 이용한 SQL 인젝션
   - 'or '1'='1과 같은 쿼리문을 입력값에 넣음
   - 이 결과 password가 무조건 참이 됨
2. Union based SQL injection 
   - 여러 개의 SQL 문을 합쳐 하나의 SQL문을 만드는 Union을 사용
   - 예시 - id : admin' UNION SELECT 1,1 -- / PW - anything
3. Bilnd SQL injection
   - 원하는 데이터를 가져올 쿼리를 삽입한다는 점에서 Error based SQL injection과는 동일
   - 단 데이터를 한번에 접근하는 것이 아니라, 서버의 참, 거짓 반응으로 데이터를 얻어내는 기술
   - 특정 아이디가 있는지 없는지를 확인하거나, 특정 데이터베이스를 쓰는지 확인하는 용도로 주로 사용
   - time과 관련된 쿼리문을 사용하는 time based로 응용 가능

### 대응

1. 유저의 입력값이 쿼리문으로 인식되는 문제이므로, 쿼리문으로 인식하지 않게 만들면 된다.

2. 입력값 검증이 필요하며, 쿼리문로 인식될 만한 문장을 문자열로 변환해주는 작업이 필요하다.

3. 입력 실패시 정보를 최소화한다.

4. 스프링에서는 preparestatement를 지원해주는 데 이를 이용하면 되며, 혹은 쿼리 캡슐화를 제공하는 프로시저를 사용한다.

   ```java
   public static String makeQuery(String str) {
    String result = "";
    if(str != null) {
    result = chkNull(replace(str, "'", ""));
    result = chkNull(replace(str, ";", ""));
    result = chkNull(replace(str, "--", ""));
    result = chkNull(replace(str, "|", ""));
    result = chkNull(replace(str, ":", ""));
    result = chkNull(replace(str, "+", ""));
    result = chkNull(replace(str, "\", ""));
    result = chkNull(replace(str, "/", ""));
    result = chkNull(replace(str.toLowerCase(), "select", ""));
    result = chkNull(replace(str.toLowerCase(), "update", ""));
    result = chkNull(replace(str.toLowerCase(), "delete", ""));
    result = chkNull(replace(str.toLowerCase(), "insert", ""));
    result = chkNull(replace(str.toLowerCase(), "where", ""));
    result = chkNull(replace(str.toLowerCase(), "from", "")); result = "'"+result+"'";
    }
   # 제거 바인딩, 실무에서는 거의 쓰지 않음
   
   // Statement 클래스
   
   // SQL 구문을 실행하는 역할
   
   //스스로는 SQL 구문을 하지 못하며, 전달만 함
   
   
   try{
    String tableName = props.getProperty("jdbc.tableName");
    String name = props.getProperty("jdbc.name")
    String qury = "SELECT * FROM ? WHERE Name = ?";
    stmt = con.perpareStatement(query);
    stmt.setString(1, tableName);
    stmt.setString(2, name);
    //매개변수 값 대입 + 매개변수 유효화 처리.(인자 작업 특화)
    rs = stmt.executeQuery();
    .....
   }
   
   ```

   



## 출처

- https://1-day-1-coding.tistory.com/2
- https://namu.wiki/w/SQL%20injection