# 트랜잭션 (Transaction)



### 트랜잭션 정의

* 하나의 논리적 작업 단위를 이루는 연산들의 집합

  > ex. 당좌예금 계좌에서 자금을 보통 예금계좌로 이체하는 작업.
  >
  > 이 작업은 거래자 입장에서 보면 하나의 단일 연산으로 볼 수 있다.
  >
  > 그러나 실제 이 계좌이체 작업은 내부적으로 여러 연산들로 구성되어 있다. 이 연산들은 전체가 정상적으로 수행 완료되거나, 도중에 실패한 경우 어떠한 연산도 일어나지 않은 상태로 되돌려져야 한다. 즉, 당좌예금 계좌에서는 자금이 빠졌는데 보통예금 계좌에서는 입금되지 않은 불완전한 상태가 일어나지 않아야 한다.
  >
  > => 사용자에게는 하나의 나눌 수 없는 단위로 보여져야 한다. 트랜잭션은 나눌 수 없기 때문에 전부가 실행되던지 또는 전부가 실행되지 않아야 한다.





### 트랜잭션 성질 (ACID 성질)

##### 	1. 원자성 (Atomicity):

​	트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 원래 상태가 되도록 해야 한다.

*"전부 아니면 전무(all-or-none)"*

##### 	2. 일관성 (Consistency):

​	고립 상태(즉, 동시에 수행되는 트랜잭션이 없는 상태)에서의 트랜잭션 수행이 데이터베이스의 일관성을 보존하여야 한다.	

##### 	3. 고립성 (Isolation):

​	여러 트랜잭션들이 동시에 수행되더라도, 모든 트랜잭션 T~i~ 와  T~j~ 의 쌍에 대하여 데이터베이스 시스템은 T~i~에게 T~i~가 시작되기 전에 T~j~가 수행을 끝마쳤거나 아니면 T~i~가 수행을 끝마친 후에 T~j~가 수행을 시작하는 것과 같이 되도록 보장해야 한다. 따라서 각 트랜잭션은 시스템에서 다른 트랜잭션이 동시에 수행하고 있는지를 알지 못한다.

##### 	4. 지속성 (Durability):

​	트랜잭션이 성공적으로 수행 완료되고 나면, 트랜잭션에 의해 데이터베이스에 변경된 내용은 시스템에 오류가 발생한다 하더라도 지속되어야 한다.

> 시스템이 트랜잭션의 정확한 수행을 보장하더라도 시스템 장애가 발생하는 경우에는 속수무책이며, 결국 시스템이 트랜잭션의 변경 사항을 잃게 되는 경우가 발생할 수 있다. 따라서 트랜잭션의 활동은 장애가 발생하여도 지속적으로 남아야 한다.





### 저장장치의 구조

저장 매체들은 상대적인 속도와 용량, 그리고 실패로부터의 복구 능력에 따라 구분되며 휘발성 저장장치 혹은 비휘발성 저장장치와 같이 분류된다. 

* ##### 휘발성 저장 장치

  * 휘발성 저장 장치 내의 정보는 시스템 장애 시에 많은 경우 손실된다. 
  * ex. 메인 메모리, 캐시 메모리

* ##### 비휘발성 저장 장치

  * 비휘발성 저장 장치에 저장된 정보는 시스템 장애 시에도 보존된다. 
  * ex. 자기 디스크, 플래시 저장 장치 등

* ##### 안정 저장 장치

  * 안정 저장 장치에 있는 정보는 ~~(이론적으로)~~ 절대 손실되지 않는다.





### 트랜잭션 상태 다이어그램

![](https://d2.naver.com/content/images/2015/06/helloworld-407507-6.png)



트랜잭션은 반드시 다음 상태 중 하나를 가져야 한다.

* **동작 (Active)** : 초기 상태로, 트랜잭션이 실행 중이면 동작 상태에 있다고 말할 수 있다.
* **부분 커밋 (Partially committed)** : 마지막 명령문이 실행된 후의 상태를 말한다.
* **실패 (Failed)** : 정상적인 실행이 더 이상 진행될 수 없을 떄 가지는 상태이다.
* **중단 (Aborted) ** : 트랜잭션이 롤백되고 데이터 베이스가 트랜잭션 시작 전 상태로 환원되고 난 후의 상태이다.
* **커밋 (Committed)** : 트랜잭션이 성공적으로 완료된 후의 상태이다.

트랜잭션이 만일 커밋되었거나 중단될 경우 그 트랜잭션은 종료(Terminated)되었다고 말할 수 있다.





#### 연산

* **커밋(Commit)**

* **롤백(Rollback)**

  * 중단된 트랜잭션에 의해 수행된 갱신 내용이 무효화될 경우 트랜잭션이 롤백되었다고 한다.

  * 트랜잭션 중단을 관리하는 복구 기법의 책임.

  * 주로 로그를 유지하는 방법을 통해서 이루어진다.

    > 트랜잭션의 모든 데이터베이스 수정은 먼저 로그에 기록된다.
    >
    > 갱신을 수행한 트랜잭션의 식별자와 수정하는 데이터 항목의 식별자 그리고 데이터 항목의 이전 값(수정하기 전)과 새로운 값(수정 후)를 기록한다.
    >
    > 그 후에야 비로소 데이터베이스가 갱신된다.
    >
    > 로그를 유지함으로써 트랜잭션 수행이 실패하는 경우 원자성을 보장하기 위해 갱신을 되돌릴 수 있고, 원자성과 지속성을 보장하기 위해 갱신을 재수행할 수 있다.

* **세이브포인트(savepoint)**

  * 전체가 아닌 특정 부분에서 트랜잭션 취소를 위해 사용
  * 취소 시점 명시 => 그 지점까지 작업 취소

![](https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Fe54a21d9-846a-412e-819a-901d1aaa34b1%2F%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%84%B8%EC%9D%B4%EB%B8%8C%ED%8F%AC%EC%9D%B8%ED%8A%B8.gif)





#### 복구

* **redo(T~i~)** : 트랜잭션 T~i~에 의해 갱신된 새로운 값으로 데이터베이스의 데이터 항목들의 값을 갱신한다. 각 트랜잭션 별로 redo 작업을 수행하지 않으며, 대신 로그를 순차적으로 스캔하며 각 로그 데이터에 대한 redo 작업을 한다. 
* **undo(T~i~)**  : 트랜잭션 T~i~에 의해 갱신된 모든 데이터 항목들을 이전 값으로 되돌린다. undo 연산은 데이터 항목을 이전 값으로 복구할 뿐만 아니라 이런 복구 과정에서 생기는 갱신 작업에 대한 로그를 기록한다. 





#### 회복 기법

* 데이터베이스 회복 기법
  * 로그 회복 기법
  * 검사 시점 회복 기법
    * 로그 기록을 이용하되, 일정 시간 간격으로 검사 시점(checkpoint)를 만듦
    * 장애 발생 시 가장 최근 검사 시점 이후의 트랜잭션에만 회복 작업 수행
    * 로그 전체를 대상으로 회복 기법을 적용할 떄 발생할 수 있는 비효율성의 문제 해결
  * 미디어 회복 기법
    * 덤프(복사본)를 이용하여 디스크에 발생할 수 있는 장애에 대비한 회복 기법
    * 디스크 장애가 발생하면, 가장 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 데이터베이스 상태로 복구하고 필요에 따라 redo 연산 수행







---

#### 질문

1. 트랜잭션은 무엇이고, 어떤 특성을 가지고 있는가?
2. 커밋과 롤백에 대해 설명해보시오.







[참고자료]

* <Database System Concepts> by Silberschatz, Korth and Sudarshan
* https://velog.io/@yu-jin-song/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction
* 
