# SQL vs NoSQL / INDEX

* 데이터베이스란?
  * 여러 사람이 공유하고 사용할 목적으로 통합 관리되는 정보의 집합 == 데이터의 모음
  * 자료 파일들을 조직적으로 통합하여 자료 항목의 중복을 없애고 자료를 구조화하여 기억시켜놓은 자료의 집합체
* 데이터를 조직화하면 데이터에 의미가 생기고, 대량의 데이터를 효율적으로 관리할 수 있게 된다.
* 데이터베이스를 만들고 관리하는 방식에 따라 데이터베이스 유형을 구분할 수 있다.
  * **SQL vs NoSQL**



## SQL (관계형 데이터베이스)

* Structured Query Language: 구조화된 쿼리 언어
* SQL은 데이터베이스 자체를 나타내는 것이 아닌, 특정 유형의 데이터베이스와 상호작용할 대 사용되는 쿼리 언어이다.
  * 이런 관계형 데이터베이스에서는 모두 초창기 관계형 데이터베이스 시스템을 위해 만들어진 SQL이라는 언어를 사용하므로, 관계형 데이터베이스를 SQL이라고 부른다.
  * 즉, SQL은 관계형 데이터베이스의 전용 프로그래밍 언어이다!



### 관계형 데이터베이스

1. 미리 **정해진 데이터 스키마(schema)**를 따라, 고정된 행과 열로 구성된 테이블에 데이터를 저장한다.

2. 데이터는 **관계**를 통해서 연결된 여러개의 테이블에 분산된다.
   * 테이블의 관계가 구조화된 데이터의 모음이기 때문에 구조화된 쿼리 언어를 사용할 수 있다.

* RDBMS 종류:
  * MySQL
  * Oracle
  * SQLite
  * MariaDB
  * PostgresSQL



#### 1. 정해진 스키마

<img src="https://blog.kakaocdn.net/dn/6S3mu/btqEiMBXW4j/0wdhiZAVukjVBdpuC0mnKk/img.png" style="zoom:50%;" >

* 각 열은 하나의 속성에 대한 정보를 저장, 행에는 각 열의 데이터 형식에 맞는 데이터가 저장
* 사전에 테이블의 구조와 데이터 타입 등을 정의하고, 이 내용에 알맞은 형태의 데이터만 삽입할 수 있다.
* 특정한 형식을 지키기 때문에, 데이터를 사용할 때 수월하다.



#### 2. 관계

![관계형 데이터베이스 란 무엇인가요? (5분 정리) - 오빠두엑셀](https://www.oppadu.com/wp-content/uploads/2021/03/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B4%80%EA%B3%84-511x300.png)

* 데이터를 여러개의 테이블에 나눠서 데이터들의 중복을 피할 수 있다.
* 하나의 테이블에서 중복없이 하나의 데이터만을 관리하기 때문에, 다른 테이블에서 부정확한 데이터를 다룰 위험이 없다.



## NoSQL (비관계형 데이터베이스)

* NoSQL은 기본적으로 SQL과 반대되는 접근방식을 따르기 때문에 지어진 이름



### 비관계형 데이터베이스

1. **스키마 없음**
2. **관계 없음**

* 데이터 모델에 따라 유형이 다양하다.

<img src="https://ud803.github.io/public/img/database-nosql.png" alt="데이터베이스" style="zoom: 50%;" />

#### 1. Document형

* 데이터를 테이블이 아닌 문서처럼 저장하는 데이터 베이스
* 많은 문서형 데이터베이스에서 JSON과 유사한 형식의 데이터를 문서화하여 저장한다.
* 각각의 문서는 하나의 속성에 대한 데이터를 가지고 있고, 컬렉션(관계형DB의 테이블과 유사)이라고 하는 그룹으로 묶어서 관리한다.
  * <img src="https://t1.daumcdn.net/cfile/tistory/99FBC9415C937F2A20" alt="img" style="zoom: 80%;" />
* 일반적인 정보를 모두 포함한 데이터를 한 컬렉션에 다 저장하고, 각 document의 형태는 다를 수 있다.
* 여러 테이블에 JOIN할 필요 없이 이미 필요한 모든 것을 갖춘 문서를 작성하게 된다.
* *[MongoDB](https://www.mongodb.com/cloud/atlas)* 



#### 2. Graph 타입

* 자료구조의 그래프와 비슷한 형식으로 데이터간의 관계를 구성하는 데이터베이스
* 노드에 속성(entity)별로 데이터를 저장한다.
* 각 노드간 관계는 선(edge)로 표현한다.
* *[Neo4J](https://neo4j.com/), [InfiniteGraph](https://objectivity.com/infinitegraph/)* 



#### 3. Key-Value 타입

* 속성을 Key-Value의 쌍으로 나타내는 데이터를 배열의 형태로 저장한다.
* Key는 속성 이름을 뜻하고, Value는 속성에 연결된 데이터값을 의미한다.
* *[Redis](https://redis.io/), [Dynamo](https://aws.amazon.com/ko/dynamodb/)* 



#### 4. Wide-Column Store 타입

* 데이터베이스의 열(column)에 대한 데이터를 집중적으로 관리하는 데이터베이스
* 각 열에는 key-value 형식으로 데이터가 저장되고, 컬럼패밀리라고 하는 열의 집합체 단위로 데이터를 처리할 수 있다.
* 하나의 행에 많은 열을 포함할 수 있어서 유연성이 높다.
* 데이터 처리에 필요한 열을 유연하게 선택할 수 있다는 점에서 규모가 큰 데이터 분석에 주로 사용되는 데이터베이스 형식이다.
* *[Cassandra](https://cassandra.apache.org/), [HBase](https://hbase.apache.org/)* 



## SQL vs NoSQL

### 수직적 확장 vs 수평적 확장 (Scailing)

<img src="https://res.cloudinary.com/academind-gmbh/image/upload/f_auto,q_auto:eco/dpr_2.0,w_400,c_limit,g_center/v1/academind.com/content/tutorials/sql-vs-nosql/horizontal-and-vertical-scaling" alt="SQL vs NoSQL" style="zoom: 67%;" />

* 수평적 확장: 서버가 추가되고 데이터베이스가 전체적으로 분산됨 => NoSQL만!
* 수직적 확장: 데이터베이스 서버의 성능을 향상시키는 것 => SQL



### 차이점

| SQL                                                          | NoSQL                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 명확하게 정의 된 스키마 -> 데이터 무결성 보장                | 유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있다. |
| 상대적으로 덜 유연하다.<br />사전에 스키마를 계획해야 하므로 나중에 수정하기가 번거로워진다. | 스키마가 없기 때문에 훨씬 유연하다. <br />저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다. |
| 각 데이터 중복없이 관계는 한번만 저장된다.                   | 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정을 해야하는 경우 모든 컬렉션에서 수행해야 한다. |
| 관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어질 수 있다. | 애플리케이션이 필요로 하는 형식으로 데이터 저장<br />데이터를 읽어오는 속도가 빨라짐 |
| 수평적 확장이 어렵고 수직적 확장만 가능, 처리량에 대해서 성장 한계에 직면할 수 있다. | 수직, 수평 확장 모두 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기/쓰기 요청 처리 가능 |



> **SQL vs NoSQL 어떤 것을 사용해야 하는가?**
>
> DB 구축에 완벽한 솔루션을 없다. 둘을 적절히 사용해 서비스에 맞게 설계하면 된다!
>
> NoSQL기반의 비관계형 데이터베이스가 확장성이나 속도면에서 뛰어나나, 고차원으로 구조화된 SQL 기반의 관계형 데이터베이스가 더 좋은 성능을 보여주는 서비스도 있다. 



#### SQL기반 관계형 데이터베이스 사용하는 케이스

1. **관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우** 
   * 데이터베이스의 ACID 성질을 준수해야 하는 경우
     * Atomicity(원자성), Consistency(일관성), Isolatino(격리성), Durability(지속성)
     * 하나의 트랜잭션에 의한 상태 변화를 수행하는 과정에서, 안전성을 보장하기 위해 필요한 성질
   * SQL을 사용하면 데이터베이스와 상호작용하는 방식을 정확하게 규정할 수 있기 때문에, 데이터 처리에서 생기는 예외적인 상황을 줄이고 데이터베이스의 무결성을 보호할 수 있다.
   * ex) 전자 상거래, 금융 서비스..
2. **변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우**
   * 소프트웨어의 규모가 많은 서버를 필요로 하지 않고 일관된 데이터를 사용하는 경우
   * 굳이 다양한 데이터유형과 높은 트래픽을 지원하도록 설계된 NoSQL을 사용할 필요가 없다.



#### NoSQL기반 비관계형 데이터베이스 사용하는 케이스

1. **정확한 데이터 구조를 알 수 없거나 변경 / 확장 될 수 있는 경우**
   * 대부분의 비관계형 데이터베이스는 저장할 수 있는 데이터의 유형에 제한이 없다.
2. **읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우)** 
3. **데이터베이스를 수평으로 확장해야 하는 경우 ( 즉, 막대한 양의 데이터를 다뤄야 하는 경우)**
   * 클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우



## INDEX

![img](https://blog.kakaocdn.net/dn/cBQD97/btqKRtpm2pl/rmo7jTbiiE9tsSQsUg0JPK/img.png)

* 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블에 대한 동작의 속도를 높여주는 자료 구조
  * 책의 중요 페이지를 표시해 놓은 목차(색인)과 같은 역할
  * 테이블의 칼럼을 색인화(index)한다.
* 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, index 파일 검색으로 속도를 향상시키는 기술
* 인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 
  * why? **해당 연산을 수행하려면 해당 대상을 조회해야만** 작업을 할 수 있기 때문



### 원리

* 테이블 생성시, 아래의 3가지 파일이 생성
  1. FRM: 테이블 구조 저장 파일
  2. MYD: 실제 데이터 파일
  3. MYI: 인덱스 정보 파일
* 인덱스에 특정 컬럼을 추게 되면 MYI에 해당 컬럼을 색인화해서 저장한다. 
  이후, 사용자가 INDEX를 사용한 SELECT 쿼리를 사용한다면 MYI 파일의 내용을 검색하게 된다. 



### 인덱스 자료구조

#### 1. 해시 테이블

* Key-Value로 데이터를 저장하는 자료구조 중 하나, 빠른 데이터 검색이 필요할 때 유용하다.
* Key값을 이용해서 고유한 인덱스를 생성하여 그 인덱스에 저장된 값을 꺼내온다.

![img](0603_SQL_NoSQL_INDEX.assets/img.png)

* (Key: 컬럼의 값, Value: 데이터의 위치) -> 컬럼의 값으로 생성된 해시를 통해 인덱스 구현.
* 시간 복잡도 O(1)로 매우 빠른 검색을 지원한다.
* 그러나, 해시가 등호(=) 연산에만 특화되어 있기 때문에 DB 인덱스에서의 쓰임은 제한적이다. 



#### 2. B+Tree

> **[B-Tree]**
>
> * 자식 노드가 2개 이상인 트리
> * 노드의 자식 수 중 최댓값을 M개라고 하면 M차 B-Tree
> * 노드의 key는 항상 반드시 정렬된 상태 (즉, 데이터가 정렬된 상태이다)
> * 모든 리프 노드들은 같은 level에 있어야 한다.
> * <img src="https://blog.kakaocdn.net/dn/BLi5L/btrdInhxyVP/ebff3uYkmyoEty5lULR8kK/img.png" alt="img" style="zoom:50%;" />
> * 주황색 화살표: 자식 노드를 가리키는 포인터
> * 연한 노랑 부분(숫자가 적힌 칸): 각 노드의 key
>   각 노드에서 key와 data는 1대1 대응형태



* 기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다. 이러한 B-Tree의 단점을 개선시킨 자료구조가 B+Tree이다. 
* 오직 리프 노드에만 데이터를 저장하고, 리프노드가 아닌 노드는 자식 포인터만 저장한다.
  * <img src="https://blog.kakaocdn.net/dn/bAARBC/btrdDydoUp7/9h4KOXBRyDNKpKDAe2ugq0/img.png" alt="img" style="zoom:67%;" />
* 리프 노드끼리는 linked list로 연결되어 있다.
* 데이터를 찾을 때, 중간 노드에서 key를 올바르게 찾아가기 위해 key가 중복될 수 있다.
* 장점
  1. 리프노드를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 노드에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다. 
  2. Full scan을 하는 경우 B+Tree는 리프노드에만 데이터가 있고 이들끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 노드를 확인해야 한다.

* 인덱스 컬럼은 <u>부등호를 이용한 순차 검색 연산</u>이 자주 발생할 수 있는데, **B+Tree의 linked list를 이용하면 순차 검색을 효율적으로 할 수 있다**!!
* 시간복잡도 O(logn)이지만, 해시테이블보다 인덱싱에 더욱 적합한 자료구조로 쓰인다. 



### 장 / 단점

* 장점:
  1. 테이블을 조회하는 속도와 그에 따른 성능 향상 가능
  2. 전반적인 시스템의 부하를 줄일 수 있다.
* 단점:
  1. 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  2. 인덱스를 관리하기 위해 추가 작업이 필요하다.
  3. 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.



### 인덱스를 사용하면 좋은 경우

- 규모가 작지 않은 테이블

- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼

  - > 삽입, 수정, 삭제가 생기면 성능이 저하될 수도 있음
    >
    > 1. 삽입
    >
    >    과정: 어느 자리에 들어가야하는지 찾는다 -> 원래 있던 데이터를 뒤로 시프트 시킨다.
    >
    >    이때 저장할 페이지가 꽉 찬 경우에는 다음 페이지로 옮겨야 해서 작업이 더 많아지게 된다.
    >    또한 인덱스는 테이블과 별도의 객체이기 때문에 테이블에도 삽입하고, 인덱스에도 삽입을 해야하기 때문에 번거롭다.
    >
    > 2. 삭제
    >    데이터를 실제로 삭제하는 게 아니라 인덱스 안에 사용 안함이라는 표시를 해주기 때문에 공간이 낭비된다.
    >
    > 3. 수정(업데이트)
    >    인덱스에는 업데이트라는 개념이 없어서 삭제 후 삽입 해줘야하기 때문에 부하가 크다.

- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼

- 데이터의 중복도가 낮은 컬럼



> 참조
>
> * https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98_%EA%B0%9C%EB%85%90
> * https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-sql-vs-nosql/
> * https://academind.com/tutorials/sql-vs-nosql
> * https://mangkyu.tistory.com/96
> * https://alreadyusedadress.tistory.com/355



